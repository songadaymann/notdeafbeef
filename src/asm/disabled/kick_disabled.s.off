	.text
	.align 2
	.globl _kick_process

// Constants table
kick_consts:
    .float 20.0          // [0] DECAY_RATE
    .float 314.159265    // [4] OMEGA = TAU*BASE_FREQ
    .float 0.8           // [8] AMP

// void kick_process(kick_t *k, float *L, float *R, uint32_t n)
// x0 = kick*, x1 = L*, x2 = R*, w3 = n
_kick_process:
    // Prologue
    stp x29, x30, [sp, #-240]!    // 128 extra bytes for q8-q15
    // Save callee-saved vector registers q8-q15 (required by AArch64 ABI)
    stp q8,  q9,  [sp, #112]
    stp q10, q11, [sp, #144]
    stp q12, q13, [sp, #176]
    stp q14, q15, [sp, #208]
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]

    // Save frequently used pointers to callee-saved regs
    mov x25, x0          // kick struct pointer (safe across calls)
    mov x23, x1          // L pointer
    mov x24, x2          // R pointer

    // Load struct members
    ldr s8,  [x25]          // sr
    str s8,  [x29, #80]      // stash sr (float)
    ldr w20, [x25, #4]      // pos
    str w20, [x29, #96]      // store current pos (uint32)
    ldr w21, [x25, #8]      // len
    str w21, [x29, #100]     // store len (uint32)

    // Early-out checks
    ldr w9, [x29, #96]
    ldr w10,[x29, #100]
    cmp w9, w10
    b.ge Ldone             // inactive
    cbz w3, Ldone          // n == 0

    // Load constants once (decay, omega, amp) into callee-saved v9-v11
    adrp x19, kick_consts@PAGE
    add  x19, x19, kick_consts@PAGEOFF
    ldr  s9,  [x19]        // decay_rate 20
    ldr  s10, [x19, #4]    // omega
    ldr  s11, [x19, #8]    // amp
    fneg s12, s9           // -decay_rate (also callee-saved v12)

    mov w22, wzr           // i counter

    // x23/x24 remain intact across libm calls (callee-saved)

Lloop:
    // Reload sampling rate and constants each iteration
    ldr  s8,  [x29, #80]
    adrp x19, kick_consts@PAGE
    add  x19, x19, kick_consts@PAGEOFF
    ldr  s9,  [x19]        // decay_rate
    ldr  s10, [x19, #4]    // omega
    ldr  s11, [x19, #8]    // amp
    fneg s12, s9

    // Exit if i >= n or pos >= len
    cmp w22, w3
    b.ge Lend
    ldr w9, [x29, #96]    // pos
    ldr w10,[x29, #100]   // len
    cmp w9, w10
    b.ge Lend

    // --- t = pos / sr ---
    ldr w9, [x29, #96]     // current pos
    ucvtf s13, w9          // t numerator
    fdiv  s13, s13, s8     // t in v13

    // env = expf(-decay_rate * t)
    fmul s0, s12, s13      // arg to expf in s0
    // Save registers before libm call
    sub sp, sp, #64
    stp x19, x20, [sp]
    stp s8, s9, [sp, #8]
    stp s10, s11, [sp, #16] 
    stp s12, s13, [sp, #24]
    stp s14, s15, [sp, #32]
    stp s16, s17, [sp, #40]
    stp s18, s19, [sp, #48]
    stp s20, s21, [sp, #56]
    bl   _expf
    // Restore registers after libm call
    ldp s20, s21, [sp, #56]
    ldp s18, s19, [sp, #48]
    ldp s16, s17, [sp, #40]
    ldp s14, s15, [sp, #32]
    ldp s12, s13, [sp, #24]
    ldp s10, s11, [sp, #16]
    ldp s8, s9, [sp, #8]
    ldp x19, x20, [sp]
    add sp, sp, #64
    str s0, [x29, #88]      // store env within fixed frame

    // tone = sinf(omega * t)
    fmul s0, s10, s13      // arg to sinf in s0
    // Save registers before libm call
    sub sp, sp, #64
    stp x19, x20, [sp]
    stp s8, s9, [sp, #8]
    stp s10, s11, [sp, #16] 
    stp s12, s13, [sp, #24]
    stp s14, s15, [sp, #32]
    stp s16, s17, [sp, #40]
    stp s18, s19, [sp, #48]
    stp s20, s21, [sp, #56]
    bl   _sinf
    // Restore registers after libm call
    ldp s20, s21, [sp, #56]
    ldp s18, s19, [sp, #48]
    ldp s16, s17, [sp, #40]
    ldp s14, s15, [sp, #32]
    ldp s12, s13, [sp, #24]
    ldp s10, s11, [sp, #16]
    ldp s8, s9, [sp, #8]
    ldp x19, x20, [sp]
    add sp, sp, #64
    fmov s15, s0           // tone

    // Reload amp in case sinf clobbered it
    ldr  s11, [x19, #8]

    // sample = env * tone * amp
    ldr s14, [x29, #88]
    fmul s0, s0, s14       // tone * env -> s0
    fmul s15, s0, s11      // *amp -> sample in s15

    // Add to L[i]
    ldr s0, [x23, w22, sxtw #2]
    fadd s0, s0, s15
    str s0, [x23, w22, sxtw #2]

    // Add to R[i]
    ldr s1, [x24, w22, sxtw #2]
    fadd s1, s1, s15
    str s1, [x24, w22, sxtw #2]

    // Increment indices
    add w9, w9, #1
    str w9, [x29, #96]
    add w22, w22, #1       // i++
    b   Lloop

Lend:
    // Store updated pos back
    ldr w9, [x29, #96]
    str w9, [x25, #4]

Ldone:
    // Epilogue
    ldp x25, x26, [sp, #64]
    // Restore callee-saved vector registers
    ldp q14, q15, [sp, #208]
    ldp q12, q13, [sp, #176]
    ldp q10, q11, [sp, #144]
    ldp q8,  q9,  [sp, #112]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #240
    ret 